# 刚体动力学模块对比分析

## 概述

本文档详细对比分析 **Rigid IPC** 项目与 **NexDynIPC** 项目中刚体动力学模块的实现差异，帮助理解两个项目的设计理念和实现方式。

---

## 1. 整体架构对比

### 1.1 模块结构对比

| 方面 | Rigid IPC | NexDynIPC |
|------|-----------|-----------|
| **项目性质** | 学术研究项目，SIGGRAPH 2021 | 自主开发项目，学习/应用导向 |
| **代码规模** | 大型，约40000+行 | 中小型，模块化设计 |
| **设计理念** | 完整的物理仿真框架 | 简洁的IPC框架实现 |
| **依赖管理** | CPM自动下载所有依赖 | vcpkg管理依赖 |

### 1.2 目录结构对比

#### Rigid IPC 结构
```
src/
├── physics/           # 物理核心
│   ├── rigid_body.hpp
│   ├── pose.hpp
│   ├── rigid_body_assembler.hpp
│   └── mass.hpp
├── ccd/              # 碰撞检测
├── barrier/          # 障碍函数
├── solvers/          # 求解器
├── time_stepper/     # 时间积分器
└── opt/              # 优化问题
```

#### NexDynIPC 结构
```
include/NexDynIPC/
├── Dynamics/         # 动力学核心
│   ├── RigidBody.hpp
│   ├── World.hpp
│   ├── IPCSolver.hpp
│   ├── Forms/        # 能量形式
│   └── Joints/       # 关节约束
├── Physics/          # 物理计算
│   ├── Contact/
│   └── Geometry/
├── Math/             # 数学工具
└── TimeIntegration/  # 时间积分
```

---

## 2. 刚体类（RigidBody）对比

### 2.1 类定义对比

#### Rigid IPC 的 RigidBody

```cpp
// 文件: src/physics/rigid_body.hpp
class RigidBody {
public:
    // 类型枚举
    enum RigidBodyType { STATIC, KINEMATIC, DYNAMIC };
    
    // 几何数据
    Eigen::MatrixXd vertices;     // 局部坐标系顶点
    Eigen::MatrixXi edges;        // 边连接
    Eigen::MatrixXi faces;        // 面连接
    
    // 物理属性
    double mass;                  // 总质量
    VectorMax3d moment_of_inertia; // 主轴转动惯量
    MatrixMax3d R0;               // 主轴到输入方向的旋转
    double r_max;                 // 质心到顶点最大距离
    DiagonalMatrixMax6d mass_matrix; // 质量矩阵
    
    // 状态
    PoseD pose;           // 当前位姿（位置+旋转）
    PoseD pose_prev;      // 前一时刻位姿
    PoseD velocity;       // 当前速度
    PoseD velocity_prev;  // 前一时刻速度
    PoseD force;          // 外力
    
    // 类型与属性
    RigidBodyType type;
    int group_id;
    VectorMax6b is_dof_fixed;  // 自由度固定标志
    
    // 运动学脚本
    double kinematic_max_time;
    std::deque<PoseD> kinematic_poses;
    
    // BVH加速结构
    BVH::BVH bvh;
};
```

#### NexDynIPC 的 RigidBody

```cpp
// 文件: include/NexDynIPC/Dynamics/RigidBody.hpp
class RigidBody {
public:
    int id = -1;
    std::string name;
    
    // 状态
    Eigen::Vector3d position = Eigen::Vector3d::Zero();
    Eigen::Quaterniond orientation = Eigen::Quaterniond::Identity();
    Eigen::Vector3d velocity = Eigen::Vector3d::Zero();
    Eigen::Vector3d angular_velocity = Eigen::Vector3d::Zero();
    Eigen::Vector3d linear_acceleration = Eigen::Vector3d::Zero();
    Eigen::Vector3d angular_acceleration = Eigen::Vector3d::Zero();

    // 物理属性
    double mass = 1.0;
    Eigen::Matrix3d inertia_body = Eigen::Matrix3d::Identity();
    bool is_static = false;
    double friction_coeff = 0.0;
    double restitution_coeff = 0.0;

    // 几何
    std::shared_ptr<Physics::Shape> shape;
    
    // 辅助方法
    Eigen::Matrix3d getInertiaWorld() const;
    Eigen::Vector3d toWorld(const Eigen::Vector3d& p_local) const;
    Eigen::Vector3d toLocal(const Eigen::Vector3d& p_world) const;
};
```

### 2.2 主要差异分析

| 特性 | Rigid IPC | NexDynIPC |
|------|-----------|-----------|
| **旋转表示** | 旋转向量（rotation vector） | 四元数（Quaternion） |
| **位姿封装** | Pose类统一管理位置和旋转 | 分离的位置和方向成员 |
| **几何存储** | 直接存储顶点/边/面 | 使用Shape抽象类 |
| **质量属性** | 对角质量矩阵 + 主轴惯量 | 3x3惯量矩阵 |
| **刚体类型** | 枚举（STATIC/KINEMATIC/DYNAMIC） | 布尔标志（is_static） |
| **运动学脚本** | 支持预定义轨迹 | 未实现 |
| **BVH结构** | 内置BVH加速 | 未实现 |
| **自由度固定** | 向量标志每个自由度 | 仅is_static标志 |

### 2.3 位姿表示差异

#### Rigid IPC - Pose类

```cpp
template <typename T> class Pose {
public:
    VectorMax3<T> position;   // 位置
    VectorMax3<T> rotation;   // 旋转向量（轴角表示）
    
    // 关键方法
    MatrixMax3<T> construct_rotation_matrix() const;
    Eigen::Quaternion<T> construct_quaternion() const;
    static Pose<T> interpolate(const Pose<T>& pose0, const Pose<T>& pose1, T t);
    
    // 自由度
    int ndof() const { return dim == 2 ? 3 : 6; }  // 2D: 3, 3D: 6
};
```

#### NexDynIPC - 分离表示

```cpp
// 直接作为RigidBody成员
Eigen::Vector3d position;           // 位置
Eigen::Quaterniond orientation;     // 四元数方向

// 更新方向的方式
double angle = theta_new.norm();
Eigen::Vector3d axis = theta_new / angle;
Eigen::Quaterniond dq(Eigen::AngleAxisd(angle, axis));
body->orientation = (dq * body->orientation).normalized();
```

**差异说明**：
- Rigid IPC 使用**旋转向量**便于优化（无约束）
- NexDynIPC 使用**四元数**便于插值和组合
- Rigid IPC 的Pose类支持**自动微分**模板化
- NexDynIPC 需要在优化时将四元数转换为增量旋转

---

## 3. 世界/场景管理对比

### 3.1 Rigid IPC - RigidBodyAssembler

```cpp
class RigidBodyAssembler {
public:
    std::vector<RigidBody> m_rbs;
    
    // 全局索引映射
    std::vector<long> m_body_vertex_id;
    std::vector<long> m_body_edge_id;
    std::vector<long> m_body_face_id;
    Eigen::VectorXi m_vertex_to_body_map;
    
    // 全局拓扑
    Eigen::MatrixXi m_edges;
    Eigen::MatrixXi m_faces;
    
    // 全局质量矩阵
    DiagonalMatrixXd m_rb_mass_matrix;
    VectorXb is_rb_dof_fixed;
    
    // 关键方法
    Eigen::MatrixXd world_vertices(const Poses<T>& poses) const;
    void global_to_local_vertex(long global_id, long& body_id, long& local_id) const;
    PosesD rb_poses(const bool previous = false) const;
};
```

### 3.2 NexDynIPC - World

```cpp
class World {
public:
    std::vector<std::shared_ptr<RigidBody>> bodies;
    std::vector<std::shared_ptr<Joint>> joints;
    std::vector<std::shared_ptr<Form>> forms;
    
    void addBody(std::shared_ptr<RigidBody> body);
    void addJoint(std::shared_ptr<Joint> joint);
    void addForm(std::shared_ptr<Form> form);
    
    int numDofs() const;
};
```

### 3.3 差异分析

| 特性 | Rigid IPC | NexDynIPC |
|------|-----------|-----------|
| **刚体存储** | 值类型vector | 智能指针vector |
| **全局拓扑** | 合并所有刚体的顶点/边/面 | 无全局拓扑 |
| **质量矩阵** | 组装全局对角质量矩阵 | 按需计算 |
| **关节支持** | 通过group_id隐式处理 | 显式Joint类 |
| **能量形式** | 硬编码在问题类中 | Form抽象类可扩展 |

---

## 4. 能量/势能计算对比

### 4.1 Rigid IPC - 硬编码方式

```cpp
class DistanceBarrierRBProblem {
public:
    // 能量项计算
    double compute_energy_term(
        const Eigen::VectorXd& x,
        Eigen::VectorXd& grad,
        Eigen::SparseMatrix<double>& hess
    );
    
    // 障碍项计算
    double compute_barrier_term(
        const Eigen::VectorXd& x,
        Eigen::VectorXd& grad,
        Eigen::SparseMatrix<double>& hess
    );
    
    // 摩擦项计算
    double compute_friction_term(...);
    
private:
    template <typename T>
    T compute_body_energy(
        const RigidBody& body,
        const Pose<T>& pose,
        const VectorMax6d& grad_barrier_t0
    );
};
```

### 4.2 NexDynIPC - Form抽象方式

```cpp
// 抽象基类
class Form {
public:
    virtual double value(const Eigen::VectorXd& x) const = 0;
    virtual void gradient(const Eigen::VectorXd& x, Eigen::VectorXd& grad) const = 0;
    virtual void hessian(const Eigen::VectorXd& x, std::vector<Eigen::Triplet<double>>& triplets) const = 0;
};

// 具体实现
class InertiaForm : public Form { /* 惯性能量 */ };
class GravityForm : public Form { /* 重力势能 */ };
class ConstraintForm : public Form { /* 约束能量 */ };

// 组合使用
class SimulationProblem : public OptimizationProblem {
    double computeValue(const Eigen::VectorXd& x) override {
        double val = inertia_form_->value(x);
        val += scaling * gravity_form_->value(x);
        val += constraint_form_->value(x);
        for (const auto& form : world_.forms) {
            val += scaling * form->value(x);
        }
        return val;
    }
};
```

### 4.3 差异分析

| 特性 | Rigid IPC | NexDynIPC |
|------|-----------|-----------|
| **设计模式** | 硬编码在问题类中 | Form抽象类组合 |
| **扩展性** | 需修改问题类 | 添加新Form即可 |
| **自动微分** | 广泛使用模板化自动微分 | 手动推导梯度/Hessian |
| **能量组合** | 编译时确定 | 运行时可配置 |

---

## 5. 时间积分对比

### 5.1 Rigid IPC - TimeStepper

```cpp
class TimeStepper {
public:
    virtual void step(
        RigidBody& body,
        const VectorMax3d& gravity,
        const double& time_step
    ) const;
    
    virtual std::string name() const = 0;
};

// Verlet积分器（2D）
class VerletTimeStepper : public TimeStepper {
    void step2D(RigidBody& body, const Eigen::Vector2d& gravity, const double& time_step) const override;
};

// DMV积分器（3D）
class DMVTimeStepper : public TimeStepper {
    void step3D(RigidBody& body, const Eigen::Vector3d& gravity, const double& time_step) const override;
};
```

### 5.2 NexDynIPC - ImplicitTimeIntegrator

```cpp
class ImplicitTimeIntegrator {
public:
    virtual void init(const Eigen::VectorXd& x, const Eigen::VectorXd& v, 
                      const Eigen::VectorXd& a, double dt);
    
    // 预测位置
    virtual Eigen::VectorXd x_tilde() const = 0;
    
    // 加速度缩放因子
    virtual double acceleration_scaling() const = 0;
    
    // 更新内部状态
    virtual void update_quantities(const Eigen::VectorXd& x_new) = 0;
    
protected:
    double dt_;
    Eigen::VectorXd x_prev_, v_prev_, a_prev_;
};

// 具体实现
class ImplicitEuler : public ImplicitTimeIntegrator { /* 隐式欧拉 */ };
class ImplicitNewmark : public ImplicitTimeIntegrator { /* Newmark方法 */ };
```

### 5.3 差异分析

| 特性 | Rigid IPC | NexDynIPC |
|------|-----------|-----------|
| **积分方式** | 显式Verlet/DMV | 隐式Euler/Newmark |
| **状态管理** | 直接更新刚体状态 | 维护内部状态向量 |
| **预测步** | 无显式预测 | x_tilde()预测位置 |
| **缩放因子** | 无 | acceleration_scaling() |
| **适用场景** | 小时间步长 | 大时间步长稳定 |

---

## 6. 求解器对比

### 6.1 Rigid IPC - 多种求解器

```cpp
// 基础牛顿求解器
class NewtonSolver : public OptimizationSolver {
    int max_iterations;
    ConvergenceCriteria convergence_criteria;
    
    bool compute_direction(...);
    bool line_search(...);
    OptimizationResults solve(const Eigen::VectorXd& x0) override;
};

// IPC自适应求解器
class IPCSolver : public NewtonSolver {
    double min_barrier_stiffness_scale;
    double dhat_epsilon;
    double max_barrier_stiffness;
    
    void post_step_update() override;  // 自适应刚度更新
};

// 同伦求解器
class HomotopySolver : public OptimizationSolver {
    double tinit, t, m, c, e_b, t_inc;
    std::unique_ptr<InnerNewtonSolver> inner_solver_ptr;
};
```

### 6.2 NexDynIPC - 简化求解器

```cpp
// 优化问题接口
class OptimizationProblem {
public:
    virtual double computeValue(const Eigen::VectorXd& x) = 0;
    virtual void computeGradient(const Eigen::VectorXd& x, Eigen::VectorXd& grad) = 0;
    virtual void computeHessian(const Eigen::VectorXd& x, Eigen::SparseMatrix<double>& hess) = 0;
};

// 牛顿求解器
class NewtonSolver {
public:
    struct Options {
        int max_iterations = 20;
        double tolerance = 1e-6;
        double line_search_rho = 0.5;
        double line_search_c1 = 1e-4;
        bool use_line_search = true;
    };
    
    bool minimize(OptimizationProblem& problem, Eigen::VectorXd& x);
};

// IPC求解器（组合使用）
class IPCSolver : public TimeIntegrator {
    Math::NewtonSolver solver_;
    std::shared_ptr<TimeIntegration::ImplicitTimeIntegrator> integrator_;
    
    void step(World& world, double dt) override;
};
```

### 6.3 差异分析

| 特性 | Rigid IPC | NexDynIPC |
|------|-----------|-----------|
| **求解器类型** | 3种（Newton/IPC/Homotopy） | 1种（Newton） |
| **自适应刚度** | IPCSolver内置 | 未实现 |
| **收敛准则** | 能量/速度两种 | 单一容差 |
| **问题接口** | 多层继承 | 简单抽象类 |
| **ALM迭代** | 无内置 | 外层循环实现 |

---

## 7. 约束处理对比

### 7.1 Rigid IPC - 碰撞约束

```cpp
class DistanceBarrierConstraint : public CollisionConstraint {
public:
    double initial_barrier_activation_distance;
    double minimum_separation_distance;
    BarrierType barrier_type;
    
    bool has_active_collisions(...) const;
    double compute_earliest_toi(...) const;
    void compute_constraints(...) ;
    double compute_minimum_distance(...) const;
    
    template <typename T>
    T distance_barrier(const T& distance, const double dhat) const;
};
```

### 7.2 NexDynIPC - 关节约束

```cpp
// 关节基类
class Joint {
public:
    virtual int dim() const = 0;
    virtual void computeC(const Eigen::VectorXd& x, Eigen::VectorXd& C) const = 0;
    virtual void computeJ(const Eigen::VectorXd& x, Eigen::SparseMatrix<double>& J) const = 0;
    
    // ALM能量
    double value(const Eigen::VectorXd& x) const;  // λᵀC + 0.5μCᵀC
    void gradient(const Eigen::VectorXd& x, Eigen::VectorXd& grad) const;
    void hessian(const Eigen::VectorXd& x, std::vector<Eigen::Triplet<double>>& triplets) const;
    
    void updateLambda(const Eigen::VectorXd& x);  // λ += μC
    
protected:
    Eigen::VectorXd lambda_;
    double mu_ = 1000.0;
};

// 具体关节
class RevoluteJoint : public Joint { /* 旋转关节 */ };
class FixedJoint : public Joint { /* 固定关节 */ };
class PrismaticJoint : public Joint { /* 滑动关节 */ };
class SphericalJoint : public Joint { /* 球关节 */ };
class CylindricalJoint : public Joint { /* 圆柱关节 */ };
```

### 7.3 差异分析

| 特性 | Rigid IPC | NexDynIPC |
|------|-----------|-----------|
| **约束类型** | 碰撞距离约束 | 关节约束 |
| **处理方法** | 障碍函数 | 增广拉格朗日（ALM） |
| **约束检测** | CCD连续碰撞检测 | 解析约束方程 |
| **刚度处理** | 自适应障碍刚度 | 固定惩罚参数 |
| **关节支持** | 无显式关节 | 多种关节类型 |

---

## 8. 碰撞检测对比

### 8.1 Rigid IPC - 完整CCD系统

```cpp
// 检测方法
enum DetectionMethod {
    BRUTE_FORCE,   // 暴力检测
    HASH_GRID,     // 哈希网格
    BVH            // 层次包围盒
};

// 轨迹类型
enum TrajectoryType {
    LINEAR,           // 线性轨迹
    PIECEWISE_LINEAR, // 分段线性
    RIGID,            // 刚体轨迹
    REDON             // Redon方法
};

// 碰撞检测主函数
void detect_collisions(
    const RigidBodyAssembler& bodies,
    const PosesD& poses_t0,
    const PosesD& poses_t1,
    const int collision_types,
    Impacts& impacts,
    DetectionMethod method,
    TrajectoryType trajectory
);

// 时间冲击计算
bool compute_edge_vertex_time_of_impact(...);
bool compute_edge_edge_time_of_impact(...);
bool compute_face_vertex_time_of_impact(...);
```

### 8.2 NexDynIPC - 基础框架

```cpp
// 宽相位检测
class BroadPhase {
public:
    virtual void update(const std::vector<std::shared_ptr<RigidBody>>& bodies) = 0;
    virtual std::vector<std::pair<int, int>> query() = 0;
};

// 障碍势能
class BarrierPotential {
public:
    static double value(double d, double d_hat, double kappa);
    static double gradient(double d, double d_hat, double kappa);
    static double hessian(double d, double d_hat, double kappa);
};
```

### 8.3 差异分析

| 特性 | Rigid IPC | NexDynIPC |
|------|-----------|-----------|
| **CCD实现** | 完整实现 | 框架定义 |
| **宽相位** | BVH/Hash Grid | 抽象接口 |
| **窄相位** | 精确TOI计算 | 未实现 |
| **轨迹类型** | 4种可选 | 未实现 |
| **碰撞类型** | EV/EE/FV | 未实现 |

---

## 9. 自动微分对比

### 9.1 Rigid IPC - 内置自动微分

```cpp
// 一阶微分
template <typename Scalar, typename Gradient>
struct DScalar1 {
    Scalar value;
    Gradient grad;
};

// 二阶微分
template <typename Scalar, typename Gradient, typename Hessian>
struct DScalar2 {
    Scalar value;
    Gradient grad;
    Hessian hess;
};

// 使用示例
template <typename T>
T compute_body_energy(const RigidBody& body, const Pose<T>& pose, ...);

// 自动计算梯度
DScalar2 f = x * x + sin(y);
double value = f.getValue();
Vector grad = f.getGradient();
Matrix hess = f.getHessian();
```

### 9.2 NexDynIPC - 手动推导

```cpp
// 手动实现梯度
void InertiaForm::gradient(const Eigen::VectorXd& x, Eigen::VectorXd& grad) const {
    int idx = 0;
    for (const auto& body : world_.bodies) {
        Eigen::Vector3d p = x.segment<3>(idx);
        Eigen::Vector3d p_hat = x_hat_.segment<3>(idx);
        grad.segment<3>(idx) = body->mass * (p - p_hat);
        
        Eigen::Vector3d theta = x.segment<3>(idx + 3);
        Eigen::Vector3d theta_hat = x_hat_.segment<3>(idx + 3);
        grad.segment<3>(idx + 3) = body->inertia_body * (theta - theta_hat);
        
        idx += 6;
    }
}
```

### 9.3 差异分析

| 特性 | Rigid IPC | NexDynIPC |
|------|-----------|-----------|
| **微分方式** | 自动微分 | 手动推导 |
| **代码复杂度** | 模板复杂 | 实现简单 |
| **正确性保证** | 自动保证 | 需验证 |
| **性能** | 编译优化 | 直接计算 |
| **维护成本** | 低 | 高 |

---

## 10. 总结与建议

### 10.1 主要差异总结

| 方面 | Rigid IPC | NexDynIPC |
|------|-----------|-----------|
| **成熟度** | 生产级研究代码 | 学习/原型阶段 |
| **功能完整性** | 完整CCD+IPC | 基础IPC框架 |
| **代码质量** | 高度优化 | 清晰易懂 |
| **关节支持** | 无 | 多种关节 |
| **碰撞处理** | 完整CCD系统 | 基础框架 |
| **自动微分** | 内置完整实现 | 未使用 |

### 10.2 NexDynIPC 可借鉴的内容

1. **自动微分系统**
   - 引入自动微分可减少手动推导错误
   - 便于实现复杂的能量函数

2. **自适应障碍刚度**
   - IPCSolver的自适应刚度更新策略
   - 提高碰撞处理的鲁棒性

3. **完整的CCD系统**
   - BVH加速结构
   - 精确的时间冲击计算

4. **Pose类封装**
   - 统一管理位置和旋转
   - 支持模板化自动微分

### 10.3 Rigid IPC 可借鉴的内容

1. **Form抽象设计**
   - 灵活的能量组合方式
   - 便于扩展新的势能形式

2. **关节约束系统**
   - ALM方法处理关节约束
   - 多种关节类型支持

3. **隐式时间积分**
   - ImplicitTimeIntegrator抽象
   - 支持多种隐式积分方案

4. **模块化设计**
   - 清晰的职责分离
   - 易于理解和维护

---

## 附录：关键代码位置对照表

| 功能 | Rigid IPC | NexDynIPC |
|------|-----------|-----------|
| 刚体定义 | `src/physics/rigid_body.hpp` | `include/NexDynIPC/Dynamics/RigidBody.hpp` |
| 位姿表示 | `src/physics/pose.hpp` | 分散在RigidBody中 |
| 世界管理 | `src/physics/rigid_body_assembler.hpp` | `include/NexDynIPC/Dynamics/World.hpp` |
| 质量计算 | `src/physics/mass.hpp` | RigidBody成员 |
| 障碍函数 | `src/barrier/barrier.hpp` | `include/NexDynIPC/Physics/Contact/Barrier.hpp` |
| 碰撞检测 | `src/ccd/ccd.hpp` | `include/NexDynIPC/Physics/Contact/BroadPhase.hpp` |
| 求解器 | `src/solvers/ipc_solver.hpp` | `include/NexDynIPC/Dynamics/IPCSolver.hpp` |
| 时间积分 | `src/time_stepper/time_stepper.hpp` | `include/NexDynIPC/TimeIntegration/ImplicitTimeIntegrator.hpp` |
| 自动微分 | `src/autodiff/autodiff.h` | 未使用 |
| 关节约束 | 无 | `include/NexDynIPC/Dynamics/Joints/Joint.hpp` |
| 能量形式 | 硬编码 | `include/NexDynIPC/Dynamics/Forms/Form.hpp` |

---

*文档版本：1.0*  
*生成日期：2026-02-12*
