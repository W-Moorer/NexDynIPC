# NexDynIPC 功能融合计划

## 文档概述

本文档规划将 **自动微分系统**、**连续碰撞检测（CCD）**、**自适应障碍刚度**、**BVH 加速结构** 和 **摩擦势能模型** 五大功能融合到 NexDynIPC 项目中的设计方案和实施路线。

---

## 1. 需求背景

### 1.1 当前项目状态

NexDynIPC 项目目前已实现：
- ✅ 刚体动力学基础框架
- ✅ Form 抽象能量系统
- ✅ 多种关节约束（Fixed/Revolute/Spherical/Prismatic/Cylindrical）
- ✅ 隐式时间积分（Implicit Euler / Implicit Newmark）
- ✅ ALM（增广拉格朗日）约束求解
- ✅ 基础障碍函数框架

### 1.2 待引入功能

| 功能 | 来源 | 引入必要性 |
|------|------|-----------|
| 自动微分 | Rigid IPC | 复杂数学模型的梯度/Hessian计算 |
| CCD | Rigid IPC | 保证无穿透的碰撞检测 |
| 自适应障碍刚度 | Rigid IPC | 提高碰撞处理鲁棒性 |
| BVH 加速结构 | Rigid IPC | 大规模刚体场景性能优化 |
| 摩擦势能模型 | Rigid IPC | 真实物理模拟必需 |

### 1.3 设计原则

1. **选择性使用自动微分**：对于可解析推导的模型（如刚体惯性能量），继续使用手动推导；对于复杂模型（如复杂几何距离计算），使用自动微分
2. **渐进式引入**：分阶段引入各功能，保证系统稳定性
3. **保持架构一致性**：新功能需与现有 Form 抽象架构兼容

---

## 2. 自动微分系统融合设计

### 2.1 设计目标

- 提供可选的自动微分能力
- 与现有手动推导代码共存
- 支持一阶（梯度）和二阶（Hessian）微分

### 2.2 模块设计

#### 2.2.1 目录结构

```
include/NexDynIPC/
├── AutoDiff/
│   ├── AutoDiff.hpp          # 核心自动微分类型定义
│   ├── AutoDiffTypes.hpp     # 类型别名和辅助函数
│   └── DScalar.hpp           # 微分标量实现（从Rigid IPC移植）
```

#### 2.2.2 核心类设计

```cpp
// AutoDiffTypes.hpp
namespace NexDynIPC::AutoDiff {

template <int N, int maxN = N>
class AutoDiffType {
public:
    // 一阶微分类型
    typedef DScalar1<double, Eigen::Matrix<double, N, 1>> DDouble1;
    
    // 二阶微分类型
    typedef DScalar2<double, Eigen::Matrix<double, N, 1>, 
                     Eigen::Matrix<double, N, N>> DDouble2;
    
    // 激活自动微分（设置变量数量）
    static void activate() {
        DiffScalarBase::setVariableCount(N);
    }
    
    // 创建微分变量
    static DDouble1 d1var(size_t i, double value);
    static DDouble2 d2var(size_t i, double value);
    
    // 提取结果
    static double get_value(const DDouble2& d);
    static Eigen::VectorXd get_gradient(const DDouble2& d);
    static Eigen::MatrixXd get_hessian(const DDouble2& d);
};

// 常用类型别名
using ADScalar1 = AutoDiffType<Eigen::Dynamic>;
using ADScalar2 = AutoDiffType<Eigen::Dynamic>;

} // namespace NexDynIPC::AutoDiff
```

#### 2.2.3 与 Form 系统集成

```cpp
// Form 接口扩展
class Form {
public:
    // 现有手动推导接口
    virtual double value(const Eigen::VectorXd& x) const = 0;
    virtual void gradient(const Eigen::VectorXd& x, Eigen::VectorXd& grad) const = 0;
    virtual void hessian(const Eigen::VectorXd& x, std::vector<Eigen::Triplet<double>>& triplets) const = 0;
    
    // 新增：自动微分接口（可选实现）
    virtual bool supportsAutoDiff() const { return false; }
    virtual double valueAutoDiff(const Eigen::VectorXd& x, 
                                  Eigen::VectorXd& grad,
                                  Eigen::SparseMatrix<double>& hess) const {
        throw std::runtime_error("AutoDiff not implemented for this Form");
    }
};

// 示例：使用自动微分的复杂距离计算
class ComplexDistanceForm : public Form {
public:
    bool supportsAutoDiff() const override { return true; }
    
    double valueAutoDiff(const Eigen::VectorXd& x,
                         Eigen::VectorXd& grad,
                         Eigen::SparseMatrix<double>& hess) const override {
        AutoDiffType<6>::activate();
        
        // 创建微分变量
        // ... 计算过程 ...
        
        return 0.0; // 返回函数值
    }
};
```

### 2.3 使用场景规划

| 场景 | 推荐方式 | 原因 |
|------|----------|------|
| 惯性能量（InertiaForm） | 手动推导 | 解析表达式简单明确 |
| 重力势能（GravityForm） | 手动推导 | 线性函数，梯度/Hessian简单 |
| 关节约束（Joint） | 手动推导 | 已有完整解析推导 |
| SDF距离计算 | 自动微分 | 复杂几何，难以解析推导 |
| 复杂接触势能 | 自动微分 | 非线性组合，自动微分更可靠 |

### 2.4 实施计划

| 阶段 | 任务 | 优先级 |
|------|------|--------|
| Phase 1 | 移植 autodiff.h 核心代码 | 高 |
| Phase 2 | 创建 AutoDiffTypes.hpp 封装 | 高 |
| Phase 3 | 扩展 Form 接口支持自动微分 | 中 |
| Phase 4 | 为复杂距离计算实现自动微分版本 | 中 |
| Phase 5 | 单元测试验证正确性 | 高 |

---

## 3. 连续碰撞检测（CCD）融合设计

### 3.1 设计目标

- 实现无穿透保证的碰撞检测
- 支持精确碰撞时间计算
- 与现有隐式积分框架兼容

### 3.2 模块设计

#### 3.2.1 目录结构

```
include/NexDynIPC/
├── Physics/
│   ├── Contact/
│   │   ├── Barrier.hpp           # 现有障碍函数
│   │   ├── BroadPhase.hpp        # 宽相位检测接口
│   │   ├── NarrowPhase.hpp       # 窄相位检测接口（新增）
│   │   └── CCD/
│   │       ├── CCD.hpp           # CCD主接口
│   │       ├── TimeOfImpact.hpp  # 碰撞时间计算
│   │       └── Interval.hpp      # 区间算术支持
```

#### 3.2.2 核心类设计

```cpp
// TimeOfImpact.hpp - 碰撞时间计算
namespace NexDynIPC::Physics::CCD {

struct ImpactResult {
    bool collision = false;
    double toi = 1.0;           // Time of Impact (0-1)
    Eigen::Vector3d point_a;    // 碰撞点在物体A上的位置
    Eigen::Vector3d point_b;    // 碰撞点在物体B上的位置
    Eigen::Vector3d normal;     // 碰撞法向量
};

class TimeOfImpactCalculator {
public:
    // 点-三角形碰撞时间
    static bool pointTriangleCCD(
        const Dynamics::RigidBody& point_body,
        const Eigen::Vector3d& local_point,
        const Dynamics::RigidBody& tri_body,
        const Eigen::Vector3d& tri_v0,
        const Eigen::Vector3d& tri_v1,
        const Eigen::Vector3d& tri_v2,
        double& toi,
        double earliest_toi = 1.0
    );
    
    // 边-边碰撞时间
    static bool edgeEdgeCCD(
        const Dynamics::RigidBody& edge1_body,
        const Eigen::Vector3d& e1_v0, const Eigen::Vector3d& e1_v1,
        const Dynamics::RigidBody& edge2_body,
        const Eigen::Vector3d& e2_v0, const Eigen::Vector3d& e2_v1,
        double& toi,
        double earliest_toi = 1.0
    );
    
    // 使用区间算术进行保守估计
    static bool conservativeCCD(
        const Dynamics::RigidBody& body_a,
        const Dynamics::RigidBody& body_b,
        double& toi
    );
};

} // namespace NexDynIPC::Physics::CCD
```

```cpp
// CCD.hpp - CCD主接口
namespace NexDynIPC::Physics::CCD {

class CCDSystem {
public:
    CCDSystem() = default;
    
    // 检测场景中所有碰撞
    std::vector<ImpactResult> detectCollisions(
        const std::vector<std::shared_ptr<Dynamics::RigidBody>>& bodies,
        double dt
    );
    
    // 计算最早碰撞时间
    double computeEarliestTOI(
        const std::vector<std::shared_ptr<Dynamics::RigidBody>>& bodies,
        double dt
    ) const;
    
private:
    std::unique_ptr<BroadPhase> broad_phase_;
};

} // namespace NexDynIPC::Physics::CCD
```

#### 3.2.3 与求解器集成

```cpp
// IPCSolver 中的 CCD 集成
class IPCSolver : public TimeIntegrator {
public:
    void step(World& world, double dt) override {
        // ... 现有代码 ...
        
        // 新增：CCD 检测
        double max_step = 1.0;
        if (enable_ccd_) {
            double toi = ccd_system_.computeEarliestTOI(world.bodies, dt);
            max_step = std::min(max_step, toi);
        }
        
        // 线搜索时使用 max_step 限制
        // ...
    }
    
private:
    CCD::CCDSystem ccd_system_;
    bool enable_ccd_ = true;
};
```

### 3.3 区间算术支持

```cpp
// Interval.hpp - 区间算术
namespace NexDynIPC::Math {

class Interval {
public:
    Interval(double lo, double hi) : lo_(lo), hi_(hi) {}
    
    double lower() const { return lo_; }
    double upper() const { return hi_; }
    double width() const { return hi_ - lo_; }
    
    // 区间运算
    Interval operator+(const Interval& other) const;
    Interval operator-(const Interval& other) const;
    Interval operator*(const Interval& other) const;
    Interval operator/(const Interval& other) const;
    
    // 三角函数
    static Interval sin(const Interval& x);
    static Interval cos(const Interval& x);
    
    // 检查是否包含零
    static bool containsZero(const Interval& x);
    
private:
    double lo_, hi_;
};

// 区间向量
using IntervalVector3 = Eigen::Matrix<Interval, 3, 1>;

} // namespace NexDynIPC::Math
```

### 3.4 实施计划

| 阶段 | 任务 | 优先级 |
|------|------|--------|
| Phase 1 | 实现区间算术基础类 | 高 |
| Phase 2 | 实现基础点-三角形 CCD | 高 |
| Phase 3 | 实现边-边 CCD | 中 |
| Phase 4 | 集成到 IPCSolver 线搜索 | 高 |

---

## 4. 自适应障碍刚度融合设计

### 4.1 设计目标

- 根据当前最小距离自动调整障碍刚度
- 防止穿透同时避免过大的刚度导致数值问题
- 与现有 Barrier 系统兼容

### 4.2 核心算法

#### 4.2.1 自适应刚度策略

来自 Rigid IPC 的策略：

```
初始刚度: κ_min = scale * average_mass / (bbox_diagonal^2)

每步更新:
if min_distance < dhat_epsilon:
    κ = min(κ * 2, κ_max)
else:
    κ 保持不变

其中:
- dhat_epsilon: 自适应激活阈值
- κ_max: 最大刚度限制
- scale: 刚度比例因子
```

#### 4.2.2 模块设计

```cpp
// AdaptiveBarrier.hpp
namespace NexDynIPC::Physics::Contact {

class AdaptiveBarrier : public BarrierPotential {
public:
    struct Parameters {
        double initial_dhat = 1e-3;           // 初始激活距离
        double dhat_epsilon = 1e-9;           // 自适应激活阈值
        double min_stiffness_scale = 1e11;    // 最小刚度比例
        double max_stiffness = 1e20;          // 最大刚度限制
    };
    
    AdaptiveBarrier(const Parameters& params = Parameters());
    
    // 设置场景参数
    void initialize(double average_mass, double bbox_diagonal);
    
    // 更新刚度（每步调用）
    void updateStiffness(double min_distance);
    
    // 获取当前刚度
    double currentStiffness() const { return kappa_; }
    
    // 获取当前激活距离
    double currentDhat() const { return dhat_; }
    
    // 障碍函数值
    double value(double distance) const override;
    double gradient(double distance) const override;
    double hessian(double distance) const override;
    
private:
    Parameters params_;
    double kappa_;      // 当前刚度
    double dhat_;       // 当前激活距离
    double kappa_min_;  // 最小刚度
    double kappa_max_;  // 最大刚度
};

} // namespace NexDynIPC::Physics::Contact
```

#### 4.2.3 与 BarrierForm 集成

```cpp
// BarrierForm.hpp（扩展现有）
namespace NexDynIPC::Dynamics {

class BarrierForm : public Form {
public:
    BarrierForm(const World& world, 
                std::shared_ptr<Physics::Contact::AdaptiveBarrier> barrier);
    
    // 每步开始时更新
    void updateBarrier(const Eigen::VectorXd& x);
    
    double value(const Eigen::VectorXd& x) const override;
    void gradient(const Eigen::VectorXd& x, Eigen::VectorXd& grad) const override;
    void hessian(const Eigen::VectorXd& x, std::vector<Eigen::Triplet<double>>& triplets) const override;
    
    // 计算当前最小距离
    double computeMinDistance(const Eigen::VectorXd& x) const;
    
private:
    const World& world_;
    std::shared_ptr<Physics::Contact::AdaptiveBarrier> barrier_;
    std::vector<ContactPair> contact_pairs_;  // 当前接触对
};

} // namespace NexDynIPC::Dynamics
```

#### 4.2.4 与 IPCSolver 集成

```cpp
// IPCSolver.cpp 中的集成
void IPCSolver::step(World& world, double dt) {
    // ... 初始化代码 ...
    
    // 创建自适应障碍
    auto adaptive_barrier = std::make_shared<Physics::Contact::AdaptiveBarrier>();
    adaptive_barrier->initialize(world.average_mass, world.bbox_diagonal);
    
    // 创建 BarrierForm
    auto barrier_form = std::make_shared<BarrierForm>(world, adaptive_barrier);
    
    for (int alm_iter = 0; alm_iter < max_alm_iters; ++alm_iter) {
        // 更新障碍刚度
        double min_dist = barrier_form->computeMinDistance(x_new);
        adaptive_barrier->updateStiffness(min_dist);
        
        // ... 求解过程 ...
    }
}
```

### 4.3 实施计划

| 阶段 | 任务 | 优先级 |
|------|------|--------|
| Phase 1 | 实现 AdaptiveBarrier 类 | 高 |
| Phase 2 | 扩展 BarrierForm 支持自适应刚度 | 高 |
| Phase 3 | 实现最小距离计算 | 高 |
| Phase 4 | 集成到 IPCSolver | 高 |
| Phase 5 | 参数调优和测试 | 中 |

---

## 5. BVH 加速结构设计

### 5.1 设计目标

- 为大规模刚体场景提供高效的碰撞检测加速
- 支持动态更新（刚体运动后快速重建/更新）
- 与现有 BroadPhase 接口兼容

### 5.2 模块设计

#### 5.2.1 目录结构

```
include/NexDynIPC/
├── Physics/
│   ├── Geometry/
│   │   ├── AABB.hpp              # 轴对齐包围盒
│   │   ├── BVH.hpp               # 层次包围盒结构
│   │   └── BVHBuilder.hpp        # BVH构建器
```

#### 5.2.2 核心类设计

```cpp
// AABB.hpp - 轴对齐包围盒
namespace NexDynIPC::Physics::Geometry {

class AABB {
public:
    AABB() : min_(Eigen::Vector3d::Constant(std::numeric_limits<double>::max())),
             max_(Eigen::Vector3d::Constant(std::numeric_limits<double>::lowest())) {}
    
    AABB(const Eigen::Vector3d& min, const Eigen::Vector3d& max)
        : min_(min), max_(max) {}
    
    // 包围盒属性
    const Eigen::Vector3d& min() const { return min_; }
    const Eigen::Vector3d& max() const { return max_; }
    Eigen::Vector3d center() const { return (min_ + max_) * 0.5; }
    Eigen::Vector3d extent() const { return max_ - min_; }
    double volume() const;
    double surfaceArea() const;
    
    // 包围盒操作
    void expand(const Eigen::Vector3d& point);
    void expand(const AABB& other);
    AABB merged(const AABB& other) const;
    bool intersects(const AABB& other) const;
    bool contains(const Eigen::Vector3d& point) const;
    
    // 膨胀包围盒（用于CCD安全边界）
    AABB inflated(double margin) const;
    
private:
    Eigen::Vector3d min_, max_;
};

} // namespace NexDynIPC::Physics::Geometry
```

```cpp
// BVH.hpp - 层次包围盒
namespace NexDynIPC::Physics::Geometry {

class BVH {
public:
    // BVH节点
    struct Node {
        AABB bbox;              // 节点包围盒
        int body_id = -1;       // 刚体ID（叶子节点有效）
        int left = -1;          // 左子节点索引
        int right = -1;         // 右子节点索引
        int parent = -1;        // 父节点索引
        
        bool isLeaf() const { return body_id >= 0; }
        bool isInternal() const { return body_id < 0 && left >= 0; }
    };
    
    BVH() = default;
    
    // 构建BVH
    void build(const std::vector<std::shared_ptr<Dynamics::RigidBody>>& bodies);
    
    // 更新BVH（刚体移动后）
    void update(const std::vector<std::shared_ptr<Dynamics::RigidBody>>& bodies);
    
    // 查询重叠对
    std::vector<std::pair<int, int>> queryOverlaps() const;
    
    // 查询与指定包围盒重叠的刚体
    std::vector<int> queryOverlaps(const AABB& bbox) const;
    
    // 获取所有节点（用于可视化/调试）
    const std::vector<Node>& nodes() const { return nodes_; }
    
    // 统计信息
    int height() const;
    int leafCount() const;
    int internalCount() const;
    
private:
    std::vector<Node> nodes_;
    int root_ = -1;
    
    // 构建辅助方法
    int buildRecursive(std::vector<int>& body_ids, int start, int end);
    void updateBoundingBox(int node_id, 
                           const std::vector<std::shared_ptr<Dynamics::RigidBody>>& bodies);
    void queryOverlapsRecursive(int node_a, int node_b, 
                                std::vector<std::pair<int, int>>& overlaps) const;
    void queryOverlapsRecursive(int node_id, const AABB& bbox,
                                std::vector<int>& results) const;
};

} // namespace NexDynIPC::Physics::Geometry
```

```cpp
// BVHBuilder.hpp - BVH构建策略
namespace NexDynIPC::Physics::Geometry {

enum class BVHSplitStrategy {
    MIDDLE,         // 中点分割
    SAH,            // 表面积启发式（Surface Area Heuristic）
    EQUAL_COUNTS    // 等数量分割
};

class BVHBuilder {
public:
    explicit BVHBuilder(BVHSplitStrategy strategy = BVHSplitStrategy::SAH);
    
    // 构建BVH
    void build(BVH& bvh, 
               const std::vector<std::shared_ptr<Dynamics::RigidBody>>& bodies);
    
private:
    BVHSplitStrategy strategy_;
    
    // 选择分割轴和位置
    int selectSplitAxis(const std::vector<AABB>& bboxes, 
                        const std::vector<int>& ids, int start, int end);
    int selectSplitPosition(const std::vector<AABB>& bboxes,
                            const std::vector<int>& ids, 
                            int start, int end, int axis);
};

} // namespace NexDynIPC::Physics::Geometry
```

#### 5.2.3 与 BroadPhase 集成

```cpp
// BroadPhase.hpp 扩展
namespace NexDynIPC::Physics::Contact {

class BVHBroadPhase : public BroadPhase {
public:
    void update(const std::vector<std::shared_ptr<Dynamics::RigidBody>>& bodies) override {
        bvh_.build(bodies);
    }
    
    std::vector<std::pair<int, int>> query() override {
        return bvh_.queryOverlaps();
    }
    
    // 带膨胀的查询（用于CCD）
    std::vector<std::pair<int, int>> queryWithInflation(double inflation);
    
private:
    Geometry::BVH bvh_;
};

} // namespace NexDynIPC::Physics::Contact
```

### 5.3 性能考虑

| 操作 | 时间复杂度 | 说明 |
|------|-----------|------|
| 构建 | O(n log n) | SAH策略，n为刚体数量 |
| 更新 | O(n) | 自底向上更新包围盒 |
| 查询 | O(k + log n) | k为重叠对数量 |

### 5.4 实施计划

| 阶段 | 任务 | 优先级 |
|------|------|--------|
| Phase 1 | 实现 AABB 类 | 高 |
| Phase 2 | 实现 BVH 基础结构 | 高 |
| Phase 3 | 实现 SAH 构建策略 | 中 |
| Phase 4 | 集成到 BroadPhase 接口 | 高 |
| Phase 5 | 性能测试和优化 | 中 |

---

## 6. 摩擦势能模型设计

### 6.1 设计目标

- 实现符合物理规律的摩擦力模型
- 与 IPC 障碍函数框架兼容
- 支持静摩擦和动摩擦

### 6.2 理论基础

#### 6.2.1 摩擦势能模型

IPC 框架中的摩擦势能采用 **滞后摩擦（Lagged Friction）** 模型：

$$P_f(x) = \sum_{k \in C} \mu_k \cdot N_k \cdot \phi_f(d_k(x))$$

其中：
- $\mu_k$ 是摩擦系数
- $N_k$ 是法向力（来自障碍势能）
- $\phi_f$ 是摩擦势能函数

#### 6.2.2 摩擦锥近似

使用 **正八面体近似** 摩擦锥：

$$\phi_f(d) = \sum_{i=1}^{n_d} b\left(\sqrt{\|T_i^T d\|^2 + \epsilon^2}\right)$$

### 6.3 模块设计

#### 6.3.1 目录结构

```
include/NexDynIPC/
├── Dynamics/
│   └── Forms/
│       └── FrictionForm.hpp     # 摩擦势能Form
├── Physics/
│   └── Contact/
│       ├── Friction.hpp         # 摩擦势能函数
│       └── FrictionCone.hpp     # 摩擦锥近似
```

#### 6.3.2 核心类设计

```cpp
// Friction.hpp - 摩擦势能函数
namespace NexDynIPC::Physics::Contact {

class FrictionPotential {
public:
    struct Parameters {
        double mu = 0.5;              // 摩擦系数
        double eps = 1e-4;            // 正则化参数
        double d_hat = 1e-3;          // 激活距离
    };
    
    explicit FrictionPotential(const Parameters& params = Parameters());
    
    // 摩擦势能值
    double value(const Eigen::Vector3d& tangent_displacement,
                 double normal_force) const;
    
    // 梯度（相对于切向位移）
    Eigen::Vector3d gradient(const Eigen::Vector3d& tangent_displacement,
                             double normal_force) const;
    
    // Hessian（相对于切向位移）
    Eigen::Matrix3d hessian(const Eigen::Vector3d& tangent_displacement,
                            double normal_force) const;
    
    // 参数设置
    void setFrictionCoefficient(double mu) { params_.mu = mu; }
    
private:
    Parameters params_;
    
    // 平滑L1范数
    double smoothL1(double x) const;
    double smoothL1Gradient(double x) const;
    double smoothL1Hessian(double x) const;
};

} // namespace NexDynIPC::Physics::Contact
```

```cpp
// FrictionCone.hpp - 摩擦锥近似
namespace NexDynIPC::Physics::Contact {

class FrictionCone {
public:
    // 离散化方向数量（正八面体近似）
    static constexpr int NUM_DIRECTIONS = 4;
    
    // 获取离散化方向
    static std::array<Eigen::Vector2d, NUM_DIRECTIONS> getDirections();
    
    // 计算摩擦力贡献
    static double computeFrictionForce(
        const Eigen::Vector2d& tangent_velocity,
        double normal_force,
        double mu
    );
};

} // namespace NexDynIPC::Physics::Contact
```

```cpp
// FrictionForm.hpp - 摩擦势能Form
namespace NexDynIPC::Dynamics {

class FrictionForm : public Form {
public:
    FrictionForm(const World& world,
                 double mu,
                 double eps = 1e-4,
                 double d_hat = 1e-3);
    
    // Form 接口实现
    double value(const Eigen::VectorXd& x) const override;
    void gradient(const Eigen::VectorXd& x, Eigen::VectorXd& grad) const override;
    void hessian(const Eigen::VectorXd& x, 
                 std::vector<Eigen::Triplet<double>>& triplets) const override;
    
    // 更新法向力（每步调用）
    void updateNormalForces(const Eigen::VectorXd& x,
                            const std::vector<double>& barrier_forces);
    
    // 更新接触点（每步调用）
    void updateContactPoints(const std::vector<ContactPair>& contacts);
    
    // 设置摩擦系数
    void setFrictionCoefficient(double mu);
    
private:
    const World& world_;
    Physics::Contact::FrictionPotential friction_;
    
    // 接触信息
    std::vector<ContactPair> contacts_;
    std::vector<double> normal_forces_;
    
    // 上一步的切向位移（用于滞后摩擦）
    Eigen::VectorXd prev_tangent_displacements_;
    
    // 辅助方法
    Eigen::Vector3d computeTangentDisplacement(
        const ContactPair& contact,
        const Eigen::VectorXd& x) const;
};

} // namespace NexDynIPC::Dynamics
```

#### 6.3.3 与 IPCSolver 集成

```cpp
// IPCSolver.cpp 中的摩擦集成
void IPCSolver::step(World& world, double dt) {
    // ... 现有代码 ...
    
    // 创建摩擦Form
    auto friction_form = std::make_shared<FrictionForm>(world, friction_coeff_);
    world.addForm(friction_form);
    
    for (int alm_iter = 0; alm_iter < max_alm_iters; ++alm_iter) {
        // ... 求解过程 ...
        
        // 更新法向力（来自障碍势能）
        std::vector<double> normal_forces = computeNormalForces(x_new);
        friction_form->updateNormalForces(x_new, normal_forces);
        
        // 更新接触点
        friction_form->updateContactPoints(current_contacts);
        
        // ... 继续求解 ...
    }
}
```

### 6.4 摩擦模型选择

| 模型 | 特点 | 适用场景 |
|------|------|----------|
| 滞后摩擦 | 使用上一步法向力 | IPC框架推荐 |
| 准静态摩擦 | 使用当前法向力 | 简单场景 |
| 惩罚摩擦 | 简单惩罚力 | 快速原型 |

### 6.5 实施计划

| 阶段 | 任务 | 优先级 |
|------|------|--------|
| Phase 1 | 实现 FrictionPotential 基础类 | 高 |
| Phase 2 | 实现 FrictionForm | 高 |
| Phase 3 | 实现法向力更新机制 | 高 |
| Phase 4 | 集成到 IPCSolver | 高 |
| Phase 5 | 摩擦参数调优和测试 | 中 |

---

## 7. 整体融合架构

### 7.1 模块依赖关系

```
┌─────────────────────────────────────────────────────────────┐
│                     Application Layer                        │
│  (SceneLoader, Simulation, StateExporter)                   │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                     Dynamics Layer                           │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────────────┐  │
│  │   World     │  │ IPCSolver   │  │ Forms (Inertia,     │  │
│  │   RigidBody │  │ + CCD       │  │ Gravity, Barrier,   │  │
│  │   Joints    │  │ + Adaptive  │  │ Friction,           │  │
│  │             │  │ + Friction  │  │ Constraint)         │  │
│  └─────────────┘  └─────────────┘  └─────────────────────┘  │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                     Physics Layer                            │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────────────┐  │
│  │   Contact   │  │    CCD      │  │     Geometry        │  │
│  │   Barrier   │  │ TimeOfImpact│  │     AABB, BVH       │  │
│  │   Friction  │  │ Trajectory  │  │     SDF, Mesh       │  │
│  │   Adaptive  │  │             │  │                     │  │
│  └─────────────┘  └─────────────┘  └─────────────────────┘  │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                     Math Layer                               │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────────────┐  │
│  │ NewtonSolver│  │ AutoDiff    │  │     Interval        │  │
│  │ LineSearch  │  │ DScalar     │  │     Arithmetic      │  │
│  └─────────────┘  └─────────────┘  └─────────────────────┘  │
└─────────────────────────────────────────────────────────────┘
```

### 7.2 数据流设计

```
仿真步进流程:

1. 状态预测 (x_tilde)
       │
       ▼
2. BVH 宽相位碰撞检测
       │
       ▼
3. CCD 计算最早碰撞时间 (toi)
       │
       ▼
4. 更新自适应障碍刚度 (kappa)
       │
       ▼
5. 牛顿迭代求解
   ├── 计算能量项 (Forms)
   │   ├── InertiaForm (手动推导)
   │   ├── GravityForm (手动推导)
   │   ├── ConstraintForm (手动推导)
   │   ├── BarrierForm (自适应刚度)
   │   └── FrictionForm (摩擦势能)
   ├── 计算梯度
   ├── 计算 Hessian
   ├── 线搜索 (受 CCD toi 限制)
   └── 收敛判断
       │
       ▼
6. 更新法向力（用于摩擦）
       │
       ▼
7. 更新状态 (position, velocity, acceleration)
```

---

## 8. 实施路线图

### 8.1 阶段划分

```
Week 1-2: 自动微分基础
├── 移植 autodiff.h 核心代码
├── 创建 AutoDiffTypes.hpp 封装
└── 单元测试验证

Week 3-4: 区间算术
├── 实现 Interval 类
└── 基础测试

Week 5-6: BVH 加速结构
├── 实现 AABB 类
├── 实现 BVH 基础结构
├── 实现 SAH 构建策略
└── 集成到 BroadPhase

Week 7-8: CCD 核心实现
├── 实现点-三角形 CCD
├── 实现边-边 CCD
├── 集成 BVH 加速
└── 集成到线搜索

Week 9-10: 自适应障碍刚度
├── 实现 AdaptiveBarrier 类
├── 扩展 BarrierForm
└── 集成到 IPCSolver

Week 11-12: 摩擦势能模型
├── 实现 FrictionPotential 类
├── 实现 FrictionForm
├── 法向力更新机制
└── 集成到 IPCSolver

Week 13-14: 集成测试
├── 端到端测试
├── 性能优化
└── 文档完善
```

### 8.2 优先级矩阵

| 功能 | 重要性 | 紧急性 | 实施难度 | 优先级 |
|------|--------|--------|----------|--------|
| 自动微分基础 | 高 | 中 | 低 | P1 |
| 区间算术 | 高 | 中 | 中 | P1 |
| BVH 加速结构 | 高 | 中 | 中 | P1 |
| CCD 核心 | 高 | 高 | 高 | P0 |
| 自适应刚度 | 高 | 高 | 中 | P0 |
| 摩擦势能模型 | 高 | 中 | 中 | P1 |
| 自动微分集成 | 中 | 低 | 中 | P2 |

### 8.3 风险与应对

| 风险 | 影响 | 应对策略 |
|------|------|----------|
| CCD 数值精度问题 | 碰撞漏检 | 使用高精度区间算术，增加安全边界 |
| 自适应刚度震荡 | 求解不收敛 | 添加刚度变化平滑机制 |
| 自动微分性能 | 计算时间增加 | 仅在必要时启用，关键路径手动推导 |
| BVH 构建开销 | 大场景启动慢 | 使用增量更新策略 |
| 摩擦数值不稳定 | 求解发散 | 使用正则化和适当的eps参数 |
| 与现有代码冲突 | 功能回归 | 完善单元测试，渐进式集成 |

---

## 9. 测试计划

### 9.1 单元测试

```cpp
// AutoDiff 测试
TEST(AutoDiffTest, GradientCorrectness) {
    AutoDiffType<2>::activate();
    auto x = AutoDiffType<2>::d2var(0, 1.0);
    auto y = AutoDiffType<2>::d2var(1, 2.0);
    
    auto f = x * x + sin(y);
    
    EXPECT_NEAR(f.getValue(), 1 + sin(2), 1e-10);
    EXPECT_NEAR(f.getGradient()(0), 2.0, 1e-10);  // df/dx = 2x
    EXPECT_NEAR(f.getGradient()(1), cos(2), 1e-10); // df/dy = cos(y)
}

// AABB 测试
TEST(AABBTest, Intersection) {
    AABB a(Eigen::Vector3d(0, 0, 0), Eigen::Vector3d(1, 1, 1));
    AABB b(Eigen::Vector3d(0.5, 0.5, 0.5), Eigen::Vector3d(1.5, 1.5, 1.5));
    AABB c(Eigen::Vector3d(2, 2, 2), Eigen::Vector3d(3, 3, 3));
    
    EXPECT_TRUE(a.intersects(b));
    EXPECT_FALSE(a.intersects(c));
}

// BVH 测试
TEST(BVHTest, BuildAndQuery) {
    BVH bvh;
    // 创建测试刚体...
    bvh.build(bodies);
    
    auto overlaps = bvh.queryOverlaps();
    // 验证重叠对正确性
}

// CCD 测试
TEST(CCDTest, PointTriangleCollision) {
    // 设置场景使点穿过三角形
    // 验证计算的 TOI 正确
}

// 自适应刚度测试
TEST(AdaptiveBarrierTest, StiffnessUpdate) {
    AdaptiveBarrier barrier;
    barrier.initialize(1.0, 10.0);
    
    double initial_kappa = barrier.currentStiffness();
    
    // 模拟距离变小
    barrier.updateStiffness(1e-10);
    
    EXPECT_GT(barrier.currentStiffness(), initial_kappa);
}

// 摩擦测试
TEST(FrictionTest, PotentialValue) {
    FrictionPotential friction;
    
    Eigen::Vector3d tangent(1.0, 0.0, 0.0);
    double normal_force = 10.0;
    
    double value = friction.value(tangent, normal_force);
    EXPECT_GT(value, 0.0);
}
```

### 9.2 集成测试场景

| 场景 | 验证目标 |
|------|----------|
| 球体自由落体 | 无穿透、能量守恒 |
| 双摆碰撞 | CCD 正确性、关节约束 |
| 堆叠物体 | 自适应刚度稳定性、BVH 性能 |
| 快速旋转物体 | CCD 正确性 |
| 斜面滑块 | 摩擦力正确性 |
| 多物体碰撞 | BVH 加速效果 |

---

## 10. 总结

本融合计划详细规划了五大功能的引入方案：

1. **自动微分系统**：作为可选能力，与手动推导共存，用于复杂几何计算
2. **CCD 系统**：保证无穿透碰撞检测，集成到线搜索过程
3. **自适应障碍刚度**：提高碰撞处理鲁棒性，自动调整刚度参数
4. **BVH 加速结构**：大规模刚体场景性能优化，支持动态更新
5. **摩擦势能模型**：真实物理模拟必需，与 IPC 框架兼容

通过渐进式实施，确保系统稳定性，同时保持与现有架构的一致性。

---

*文档版本：2.0*  
*生成日期：2026-02-12*
